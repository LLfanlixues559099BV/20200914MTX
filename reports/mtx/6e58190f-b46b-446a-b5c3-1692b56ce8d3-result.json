{"name": "test_order", "status": "broken", "statusDetails": {"message": "TypeError: 'Session' object is not iterable", "trace": "self = <script.test_mtx_order.TestOrder object at 0x0000020B72B025C0>\n\n    def test_order(self):\n        MtxLogin().login_success(self.session)\n    \n>       res_order = self.order.order(self.session)\n\nscript\\test_mtx_order.py:19: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \napi\\loginOder.py:24: in order\n    response = session.post(self.url, session, data, headers=HEADERS)\nc:\\python3.6\\lib\\site-packages\\requests\\sessions.py:578: in post\n    return self.request('POST', url, data=data, json=json, **kwargs)\nc:\\python3.6\\lib\\site-packages\\requests\\sessions.py:530: in request\n    resp = self.send(prep, **send_kwargs)\nc:\\python3.6\\lib\\site-packages\\requests\\sessions.py:643: in send\n    r = adapter.send(request, **kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <requests.adapters.HTTPAdapter object at 0x0000020B72B3B438>, request = <PreparedRequest [POST]>, stream = False\ntimeout = Timeout(connect=None, read=None, total=None), verify = True, cert = None\nproxies = OrderedDict([('http', 'http://127.0.0.1:8888'), ('https', 'https://127.0.0.1:8888')])\n\n    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):\n        \"\"\"Sends PreparedRequest object. Returns Response object.\n    \n        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.\n        :param stream: (optional) Whether to stream the request content.\n        :param timeout: (optional) How long to wait for the server to send\n            data before giving up, as a float, or a :ref:`(connect timeout,\n            read timeout) <timeouts>` tuple.\n        :type timeout: float or tuple or urllib3 Timeout object\n        :param verify: (optional) Either a boolean, in which case it controls whether\n            we verify the server's TLS certificate, or a string, in which case it\n            must be a path to a CA bundle to use\n        :param cert: (optional) Any user-provided SSL certificate to be trusted.\n        :param proxies: (optional) The proxies dictionary to apply to the request.\n        :rtype: requests.Response\n        \"\"\"\n    \n        try:\n            conn = self.get_connection(request.url, proxies)\n        except LocationValueError as e:\n            raise InvalidURL(e, request=request)\n    \n        self.cert_verify(conn, request.url, verify, cert)\n        url = self.request_url(request, proxies)\n        self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)\n    \n        chunked = not (request.body is None or 'Content-Length' in request.headers)\n    \n        if isinstance(timeout, tuple):\n            try:\n                connect, read = timeout\n                timeout = TimeoutSauce(connect=connect, read=read)\n            except ValueError as e:\n                # this may raise a string formatting error.\n                err = (\"Invalid timeout {}. Pass a (connect, read) \"\n                       \"timeout tuple, or a single float to set \"\n                       \"both timeouts to the same value\".format(timeout))\n                raise ValueError(err)\n        elif isinstance(timeout, TimeoutSauce):\n            pass\n        else:\n            timeout = TimeoutSauce(connect=timeout, read=timeout)\n    \n        try:\n            if not chunked:\n                resp = conn.urlopen(\n                    method=request.method,\n                    url=url,\n                    body=request.body,\n                    headers=request.headers,\n                    redirect=False,\n                    assert_same_host=False,\n                    preload_content=False,\n                    decode_content=False,\n                    retries=self.max_retries,\n                    timeout=timeout\n                )\n    \n            # Send the request.\n            else:\n                if hasattr(conn, 'proxy_pool'):\n                    conn = conn.proxy_pool\n    \n                low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)\n    \n                try:\n                    low_conn.putrequest(request.method,\n                                        url,\n                                        skip_accept_encoding=True)\n    \n                    for header, value in request.headers.items():\n                        low_conn.putheader(header, value)\n    \n                    low_conn.endheaders()\n    \n>                   for i in request.body:\nE                   TypeError: 'Session' object is not iterable\n\nc:\\python3.6\\lib\\site-packages\\requests\\adapters.py:469: TypeError"}, "start": 1599149733866, "stop": 1599149734016, "uuid": "a6707aa4-254b-4cab-b90d-72d8a1452188", "historyId": "5f149e3ac521bd9761cd04d7d8d26275", "testCaseId": "1f02b004fadc5a3e5f88f371700624a2", "fullName": "script.test_mtx_order.TestOrder#test_order", "labels": [{"name": "parentSuite", "value": "script"}, {"name": "suite", "value": "test_mtx_order"}, {"name": "subSuite", "value": "TestOrder"}, {"name": "host", "value": "LAPTOP-TJH92AQ2"}, {"name": "thread", "value": "32552-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "script.test_mtx_order"}]}